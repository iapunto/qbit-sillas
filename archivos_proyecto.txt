

/* ===================== Archivo: .eslintrc.json ===================== */

{
    "env": {
      "browser": true,
      "node": true,
      "es2021": true
    },
    "extends": [
      "eslint:recommended",
      "plugin:@typescript-eslint/recommended",
      "plugin:builderbot/recommended"
    ],
    "parser": "@typescript-eslint/parser",
    "parserOptions": {
      "ecmaVersion": "latest",
      "sourceType": "module"
    },
    "plugins": ["@typescript-eslint", "builderbot"],
    "rules": {
      "@typescript-eslint/no-explicit-any": "off",
      "@typescript-eslint/no-unused-vars": "off",
      "@typescript-eslint/ban-ts-comment": "off",
      "@typescript-eslint/ban-types": "off",
      "no-unsafe-optional-chaining": "off"
    }
  }
  

/* ===================== Archivo: nodemon.json ===================== */

{
    "watch": ["src"],
    "ext": "ts",
    "ignore": [
      "**/*.test.ts",
      "**/*.spec.ts"
  ],
    "delay": "3",
    "execMap": {
      "ts": "tsx"
    }
  }

/* ===================== Archivo: package.json ===================== */

{
  "name": "base-bailey-json",
  "version": "1.0.0",
  "description": "",
  "main": "dist/app.js",
  "type": "module",
  "scripts": {
    "start": "node ./dist/app.js",
    "lint": "eslint . --no-ignore",
    "dev": "npm run lint && nodemon ./src/app.ts",
    "build": "npx rollup -c"
  },
  "keywords": [],
  "dependencies": {
    "@builderbot-plugins/gemini-layer": "^0.0.2",
    "@builderbot-plugins/url-to-base64": "^1.0.0",
    "@builderbot/bot": "1.2.5",
    "@builderbot/provider-meta": "1.2.5",
    "@google/generative-ai": "^0.24.0",
    "@langchain/core": "^0.3.48",
    "@langchain/google-genai": "^0.2.4",
    "date-fns": "^4.1.0",
    "date-fns-tz": "^3.2.0"
  },
  "devDependencies": {
    "@types/dotenv": "^8.2.0",
    "@types/node": "^20.11.30",
    "@typescript-eslint/eslint-plugin": "^7.2.0",
    "@typescript-eslint/parser": "^7.4.0",
    "eslint": "^8.52.0",
    "eslint-plugin-builderbot": "latest",
    "nodemon": "^3.1.0",
    "rollup": "^4.10.0",
    "rollup-plugin-typescript2": "^0.36.0",
    "tsx": "^4.7.1",
    "typescript": "^5.4.3"
  },
  "author": "",
  "license": "ISC"
}


/* ===================== Archivo: src\app.ts ===================== */

import { createBot, createFlow } from "@builderbot/bot";
import { provider } from "~/provider";
import { adapterDB } from "~/database";
import welcomeFlow from "~/flows/welcome.flow";
import { config } from "~/config";
import sellerFlow from "~/flows/seller.flow";

const PORT = config.port;

const main = async () => {
  console.log("Iniciando la aplicación..."); // Log al inicio
  const adapterFlow = createFlow([welcomeFlow, sellerFlow]);
  const { httpServer } = await createBot({
    flow: adapterFlow,
    provider: provider,
    database: adapterDB,
  });
  httpServer(+PORT);
  console.log(`Servidor escuchando en el puerto ${PORT}`); // Log del puerto
};

main();


/* ===================== Archivo: src\config\index.ts ===================== */

// src/config.ts

import dotenv from "dotenv";

// Cargar las variables de entorno desde el archivo .env
dotenv.config();

// Lista de variables requeridas
const requiredEnvVars = [
  "JWT_TOKEN",
  "NUMBER_ID",
  "VERIFY_TOKEN",
  "VERSION",
  "GOOGLE_API_KEY",
  "PORT",
];

// Validar que todas las variables requeridas estén definidas
for (const varName of requiredEnvVars) {
  if (!process.env[varName]) {
    throw new Error(`La variable de entorno ${varName} no está definida.`);
  }
}

// Exportar las variables de entorno como constantes
export const config = {
  jwtToken: process.env.JWT_TOKEN!,
  numberId: process.env.NUMBER_ID!,
  verifyToken: process.env.VERIFY_TOKEN!,
  version: process.env.VERSION!,
  googleApiKey: process.env.GOOGLE_API_KEY!,
  port: parseInt(process.env.PORT!, 10),
};


/* ===================== Archivo: src\data\products.ts ===================== */

export const productList = [
  {
    name: "Silla Ergonómica Sihoo Doro S300 - Gris",
    price: "$3.550.000",
    link: "https://sillas.com.co/tienda/silla-sihoo-doro-s300/?attribute_color=Gris",
  },
  {
    name: "Silla Ergonómica Sihoo Doro S300 - Negro",
    price: "$3.465.000",
    link: "https://sillas.com.co/tienda/silla-sihoo-doro-s300/?attribute_color=Negro",
  },
  {
    name: "Silla de Oficina Ergonómica Sihoo M102",
    price: "$683.000",
    link: "https://sillas.com.co/tienda/silla-de-oficina-ergonomica-sihoo-m102/",
  },
  {
    name: "Silla Ergonómica Sihoo Presidencial Star V1",
    price: "$2.250.000",
    link: "https://sillas.com.co/tienda/silla-sihoo-presidencial-star-v1/",
  },
  {
    name: "Silla Ergonómica Sihoo Doro C300 Pro",
    price: "$2.650.000 – $2.735.000",
    link: "https://sillas.com.co/tienda/silla-ergonomica-sihoo-doro-c300-pro/",
  },
  {
    name: "Silla Ergonómica Sihoo Ergomax M97B",
    price: "$2.600.000",
    link: "https://sillas.com.co/tienda/silla-ergonomica-sihoo-ergomax-m97b/",
  },
  {
    name: "SILLA GERENCIAL DELPHI ALUMINIO",
    price: "$680.000",
    link: "https://sillas.com.co/tienda/silla-gerencial-delphi-aluminio/",
  },
  {
    name: "SILLA GERENCIAL DELPHI BASE NEGRA",
    price: "$600.000",
    link: "https://sillas.com.co/tienda/silla-gerencial-delphi-base-negra/",
  },
  {
    name: "SILLA GERENCIAL NEFI GRIS",
    price: "$1.900.000",
    link: "https://sillas.com.co/tienda/silla-gerencial-nefi-gris/",
  },
  {
    name: "SILLA OPERATIVA DELPHI BASE NEGRA",
    price: "$450.000",
    link: "https://sillas.com.co/tienda/silla-operativa-delphi-base-negra/",
  },
  {
    name: "SILLA OPERATIVA DELPHI CROMADA",
    price: "$485.000",
    link: "https://sillas.com.co/tienda/silla-operativa-delphi-cromada/",
  },
  {
    name: "SILLA PRESIDENCIAL MANHATTAN ECO",
    price: "$1.700.000",
    link: "https://sillas.com.co/tienda/silla-presidencial-manhattan-eco/",
  },
  {
    name: "SILLA PRESIDENCIAL NIZA",
    price: "$465.000",
    link: "https://sillas.com.co/tienda/silla-presidencial-niza/",
  },
  {
    name: "SILLA PRESIDENCIAL OSAKA",
    price: "$818.678",
    link: "https://sillas.com.co/tienda/silla-presidencial-osaka/",
  },
  {
    name: "SILLA SIHOO S50",
    price: "$1.850.000 (Agotado)",
    link: "https://sillas.com.co/tienda/silla-sihoo-s50/",
  },
  {
    name: "SILLA THINK GERENTE NEGRA",
    price: "$750.000",
    link: "https://sillas.com.co/tienda/silla-think-gerente-negra/",
  },
];


/* ===================== Archivo: src\data\services.ts ===================== */

export const servicesData = [
  {
    name: "Marketing Digital con IA",
    description:
      "Implementamos estrategias innovadoras de marketing digital optimizadas con inteligencia artificial para maximizar tu presencia online y aumentar tus conversiones.",
    benefits: [
      "SEO avanzado (On-Page y Off-Page)",
      "Campañas publicitarias en Google Ads, Meta Ads, LinkedIn Ads y TikTok Ads",
      "Generación de contenido optimizado para SEO",
      "Gestión estratégica de redes sociales",
    ],
  },
  {
    name: "Diseño y Desarrollo Web",
    description:
      "Creamos sitios web profesionales, personalizados y optimizados para mejorar la experiencia del usuario y aumentar las conversiones.",
    benefits: [
      "Diseño UX/UI enfocado en la conversión",
      "Desarrollo de tiendas online con funcionalidades avanzadas",
      "Optimización de velocidad y rendimiento",
      "Mantenimiento técnico continuo",
    ],
  },
  {
    name: "Chatbots Inteligentes",
    description:
      "Diseñamos e implementamos chatbots automatizados que mejoran la atención al cliente y optimizan la gestión de leads.",
    benefits: [
      "Automatización de respuestas frecuentes",
      "Integración con sistemas CRM",
      "Flujos de conversación personalizados",
      "Mejora en la satisfacción del cliente",
    ],
  },
  {
    name: "Desarrollo de Aplicaciones Móviles",
    description:
      "Desarrollamos aplicaciones móviles intuitivas y funcionales para iOS y Android, adaptadas a las necesidades de tu negocio.",
    benefits: [
      "Desarrollo híbrido y nativo",
      "Notificaciones push y autenticación de usuarios",
      "Integración con sistemas empresariales (CRMs, ERPs, APIs)",
      "Optimización ASO para mayor visibilidad",
    ],
  },
  {
    name: "Implementación de Odoo ERP",
    description:
      "Configuramos y personalizamos Odoo ERP para gestionar de manera integral todos los procesos de tu empresa.",
    benefits: [
      "Configuración de módulos básicos (CRM, ventas, facturación, contabilidad)",
      "Personalización avanzada según tus necesidades",
      "Automatización de flujos de trabajo",
      "Capacitación y soporte técnico prioritario",
    ],
  },
  {
    name: "Optimización y Conversión (CRO)",
    description:
      "Analizamos y optimizamos tu sitio web para aumentar la tasa de conversión y mejorar la experiencia del usuario.",
    benefits: [
      "Pruebas A/B para mejorar rendimientos",
      "Análisis de embudos de conversión",
      "Pruebas de usabilidad con usuarios reales",
      "Mejoras en la interfaz y navegación",
    ],
  },
  {
    name: "Automatización Inteligente",
    description:
      "Diseñamos flujos de trabajo automatizados para aumentar la eficiencia operativa y reducir costos.",
    benefits: [
      "Automatización de procesos repetitivos",
      "Integración de herramientas y sistemas",

      "Sincronización de datos entre plataformas",
      "Soluciones personalizadas para tu negocio",
    ],
  },
  {
    name: "Email Marketing",
    description:
      "Creamos campañas de email marketing efectivas para conectar con tu audiencia y fidelizar clientes.",
    benefits: [
      "Diseño de plantillas atractivas y optimizadas",
      "Automatización de flujos de email",
      "Segmentación y personalización avanzada",
      "Mejora en la tasa de apertura y clics",
    ],
  },
  {
    name: "Consultoría y Estrategia Digital",
    description:
      "Ofrecemos asesoramiento experto para planificar y ejecutar estrategias digitales que impulsen el crecimiento de tu negocio.",
    benefits: [
      "Auditorías digitales completas",
      "Planificación estratégica de marketing digital",
      "Capacitación en IA y tecnología avanzada",
      "Asesoramiento personalizado",
    ],
  },
];


/* ===================== Archivo: src\database\index.ts ===================== */

import { MemoryDB as Database } from "@builderbot/bot";

export const adapterDB = new Database();


/* ===================== Archivo: src\flows\seller.flow.ts ===================== */

import { addKeyword, EVENTS } from "@builderbot/bot";
import GeminiService from "../services/geminiService";
import { getHistoryParse, handleHistory } from "../utils/handledHistory";
import { servicesData } from "../data/services";
// Asegúrate de tener tus servicios aquí
import { generateTimer } from "../utils/generateTimer";
// Importa la función para generar el tiempo de espera

const PROMPT_SELLER = `
    Eres qBit, un asistente de IA experto en comprender las intenciones de los usuarios y responder preguntas sobre IA Punto.
    ### INSTRUCCIONES IMPORTANTES:
    - Si el usuario envía un saludo inicial (como "hola", "buenas", etc.), responde con: 
      "¡Hola! Soy qBit, tu asistente virtual de IA Punto Soluciones Tecnológicas. 😊 ¿En qué puedo ayudarte hoy?".
    - Si el usuario ya ha recibido el saludo inicial y sigue enviando saludos repetidos o mensajes sin intención clara, responde con:
      "Lo siento, no puedo entender lo que me dices. ¿Puedes ser más específico? 😕".
    - Si el historial de conversación muestra que el usuario ha interactuado contigo varias veces (más de 5 mensajes) y sigue sin proporcionar una intención clara, responde con:
      "He notado que has estado saludando varias veces. 😊 ¿Te gustaría saber más sobre nuestros servicios o tienes alguna pregunta específica?".
    - Si el usuario tiene una pregunta general, respóndele utilizando la información de los servicios.
    - Si no reconoces una intención clara, responde con:
      "Lo siento, no puedo entender la intención del usuario. 😕 ¿Puedes ser más específico?".
    - Si existe un interés en un servicio y/o producto o solicitan información adicional que no tengas, ofrece el Agendar una reunión.
    - Somos facturadores electrónicos, emitimos factura electronica en Colombia. También integramos la facturación electronica a sistemas existentes.
    en este caso se debe interpretar bien lo que el usuario esta preguntando si las emitimos legalmente para cumplir con las normativas DIAN o las integramos en su sistema para que ellos emitan facturas.
    ### INFORMACIÓN SOBRE IA PUNTO:
    Somos IA Punto, donde cada byte cuenta y cada idea es un rayo de innovación.
    Somos más que una agencia de marketing digital; somos arquitectos de experiencias digitales, creadores de conexiones impactantes entre marcas y audiencias.
    En IA Punto, desafiamos las normas y abrazamos la locura creativa, porque creemos que la innovación nace de la libertad.
    Lo Que Nos Define:
    En IA Punto, la inteligencia artificial no solo está en nuestro nombre, está en nuestro ADN.
    Cada estrategia es un algoritmo de creatividad, cada campaña es un experimento de innovación.
    Somos impulsados por la curiosidad y alimentamos nuestra creatividad con el combustible de la libertad.
    Nuestro Compromiso:
    Más allá de los servicios, nos comprometimos a ser tus aliados en el viaje digital.
    Tu éxito es nuestro éxito, y nos embarcamos en cada proyecto con pasión y determinación.
    Aquí, la locura es bienvenida, la creatividad es esencial, y cada desafío es una oportunidad de brillar.
    Principios:
    * Innovación Constante
    * Colaboración sin Límites
    * Transparencia Total
    * Pasión Imparable

    ¿Por qué trabajar con nosotros?
    * Innovación sin Límites
    * Equipo Apasionado
    * Transparencia Total
    * Resultados Tangibles
    * Experiencia Personalizada
    * Compromiso Sostenible

    Horario de atención: lunes a viernes, de 09:00 a 12:00 y de 13:00 a 17:00.
    Sitio web: www.iapunto.com
    Correo: hola@iapunto.com
    Teléfono: +57 316 376 9935

    ### HISTORIAL DE LA CONVERSACIÓN:
    {HISTORY}

    ### MENSAJE DEL USUARIO:
    {MESSAGE}

    ### Servicios de IA Punto:
    {SERVICES}

    Responde de forma concisa y amigable siguiendo las instrucciones anteriores.
`;

// Función para generar el prompt dinámico
const generatePromptSeller = (history: string, message: string) => {
  const services = JSON.stringify(servicesData); // Convierte los servicios a JSON
  return PROMPT_SELLER.replace("{HISTORY}", history)
    .replace("{MESSAGE}", message)
    .replace("{SERVICES}", services);
};

const sellerFlow = addKeyword(EVENTS.ACTION).addAction(
  async (ctx, { state, flowDynamic, gotoFlow }) => {
    try {
      console.log("Recibido mensaje del usuario:", ctx.body); // Log de recepción
      const geminiServices = new GeminiService();
      const history = getHistoryParse(state);
      console.log("Historial de conversación:", history);

      // Genera el prompt dinámico
      const prompt = generatePromptSeller(history, ctx.body);
      console.log("Prompt generado:", prompt); // Log del prompt

      // Obtiene la respuesta del modelo
      const result = await geminiServices.generateContent(prompt);
      const response = result.response.text();
      console.log("Respuesta del modelo:", response); // Log de la respuesta

      // Almacena la respuesta en el historial
      await handleHistory({ content: response, role: "assistant" }, state);

      // Divide la respuesta en fragmentos para enviarlos gradualmente
      const chunks = response.split(/(?<!\d)\.\s+/g);
      for (const chunk of chunks) {
        // Simular un retraso de 5 segundos para procesar la solicitud

        await flowDynamic([
          { body: chunk.trim(), delay: generateTimer(2000, 3500) },
        ]);
        console.log("Mensaje enviado al usuario:", chunk.trim()); // Log de envío
      }
    } catch (error: any) {
      console.error("Error en el flujo 'sellerFlow':", error.message || error);
      await flowDynamic(
        "Lo siento, no puedo generar una respuesta en este momento. 😕"
      );
    }
  }
);

export default sellerFlow;


/* ===================== Archivo: src\flows\welcome.flow.ts ===================== */

import { addKeyword, EVENTS } from "@builderbot/bot";
import intentFlow from "~/layers";
import conversationalLayer from "~/layers/conversational.layer";

const welcomeFlow = addKeyword(EVENTS.WELCOME)
  .addAction(conversationalLayer)
  .addAction(intentFlow);

export default welcomeFlow;


/* ===================== Archivo: src\layers\conversational.layer.ts ===================== */

import { BotContext, BotMethods } from "@builderbot/bot/dist/types";
import { handleHistory } from "../utils/handledHistory";

/**
 * Stores all user messages in the `state`.
 *
 * @param ctx - Bot context, including the user's message.
 * @param methods - Bot methods, such as `state`.
 */
export default async (
  ctx: BotContext,
  { state }: BotMethods
): Promise<void> => {
  const { body } = ctx;

  try {
    // Validate that the message is not empty
    if (!body || body.trim().length === 0) {
      console.warn("The user's message is empty or contains only whitespace.");
      return;
    }

    // Store the message in the history
    await handleHistory({ content: body.trim(), role: "user" }, state);
    console.log("Mensaje guardado en el historial:", body.trim()); // Log para verificar el almacenamiento
  } catch (error) {
    console.error("Error en conversationalLayer:", error);
    throw error; // Propagate the error to be handled at higher levels if necessary
  }
};


/* ===================== Archivo: src\layers\index.ts ===================== */

import { addKeyword, EVENTS } from "@builderbot/bot";
import MainLayer from "./main.layer";
import { BotContext, BotMethods } from "@builderbot/bot/dist/types";
import sellerFlow from "../flows/seller.flow";

const intentions = new MainLayer();

const intentFlow = addKeyword(EVENTS.ACTION).addAction(
  async (ctx: BotContext, { gotoFlow, flowDynamic, state }: BotMethods) => {
    try {
      // Obtener el mensaje del usuario
      const message = ctx.body;
      console.log("Mensaje recibido: ", message);

      // Determinar la intención del usuario
      const intention = await intentions.determineIntent(message, state);
      console.log("Intención detectada: ", intention);

      // Log adicional para debug
      console.log("Tipo de dato de intención:", typeof intention);
      console.log("Valor exacto de intención:", `"${intention}"`);

      console.log(
        `Comparando: "${intention.trim().toUpperCase()}" con "HABLAR"`
      );
      // Seleccionar la acción adecuada según la intención del usuario
      if (intention && intention.trim().toUpperCase() === "HABLAR") {
        console.log("Redirigiendo a sellerFlow");
        return gotoFlow(sellerFlow);
      } else {
        console.log("No se reconoció la intención, enviando mensaje de error");
        await flowDynamic(
          "Lo siento, no pude entender tu mensaje. ¿Podrías reformularlo?"
        );
      }
    } catch (error) {
      console.error(error);
    }
  }
);

export default intentFlow;


/* ===================== Archivo: src\layers\main.layer.ts ===================== */

import GeminiService from "~/services/geminiService";
import { getHistoryParse } from "~/utils/handledHistory";

class MainLayer {
  // Intention detection
  async determineIntent(message: string, state: any): Promise<string> {
    const ia = new GeminiService();
    const history = getHistoryParse(state);

    const prompt = `Eres un asistente de IA experto en comprender las intenciones de los usuarios.
    Tu tarea es analizar el mensaje del usuario y determinar su intención principal.
    ### Historial de Conversación ###
    ${history}

    ### Mensaje del usuario: ###
    ${message}

    Posibles acciones a realizar:

    HABLAR: Esta acción se debe realizar cuando el cliente desea hacer una pregunta o necesita más información sobre IA Punto o sus servicios.
    Objetivo:

    Comprender la intención del cliente en el contexto de la conversación con IA Punto y seleccionar 
    la acción más adecuada en respuesta a su declaración.
    Consideraciones:

    * IA Punto ofrece servicios de Marketing y desarrollo web/móvil impulsadas por la Inteligencia Artificial.
    * El objetivo principal del bot es guiar al cliente, identificar sus necesidades y una vez identificada una intención o interés en un producto/servicio persuadir para que agende una reunión con un asesor.
    * El bot debe ser amigable, profesional y servicial.

    ### Instrucciones ###
      Analiza el mensaje del usuario y selecciona la acción más adecuada.
    Respuesta ideal (HABLAR):`;

    try {
      const result = await ia.generateContent(prompt);
      let intention = result.response.text().trim();
      // Ajusta según la estructura de la respuesta

      console.log("Respuesta cruda del modelo:", intention);
      // Extraer solo la primera palabra (la intención principal)
      const firstWordMatch = intention.match(/^\w+/);
      if (!firstWordMatch) {
        console.warn("No se pudo extraer la intención principal del modelo.");
        return "UNKNOWN";
      }

      intention = firstWordMatch[0].toUpperCase();

      console.log("Intención extraída:", intention);
      // Validar que la intención sea una de las opciones válidas
      const validIntents = ["HABLAR"];
      if (!validIntents.includes(intention)) {
        console.warn("Intención no válida detectada:", intention);
        return "UNKNOWN"; // Devuelve una intención desconocida si no coincide
      }

      return intention;
    } catch (error: any) {
      console.error(
        "Error al determinar la intención:",
        error.message || error
      );
      throw error; // Propaga el error para manejarlo en niveles superiores
    }
  }
}

export default MainLayer;


/* ===================== Archivo: src\provider\index.ts ===================== */

// src/provider.ts

import { createProvider } from "@builderbot/bot";
import { MetaProvider } from "@builderbot/provider-meta";
import { config } from "~/config";

export const provider = createProvider(MetaProvider, {
  jwtToken: config.jwtToken,
  numberId: config.numberId,
  verifyToken: config.verifyToken,
  version: config.version,
});


/* ===================== Archivo: src\services\geminiService.ts ===================== */

import { GoogleGenerativeAI } from "@google/generative-ai";
import { config } from "../config";

class GeminiService {
  private genAI: GoogleGenerativeAI;
  private model: any; // Puedes especificar el tipo más adelante si es necesario

  constructor() {
    this.genAI = new GoogleGenerativeAI(config.googleApiKey as string);
    this.model = this.genAI.getGenerativeModel({ model: "gemini-pro" });
  }

  async generateContent(prompt: string): Promise<any> {
    try {
      const result = await this.model.generateContent(prompt);
      const response = result.response;

      if (!response || !response.text) {
        console.warn("Respuesta del modelo vacía o sin texto.");
        return {
          response: { text: () => "Lo siento, no obtuve una respuesta clara." },
        };
      }

      return { response };
    } catch (error: any) {
      console.error("Error al generar contenido:", error.message || error);
      // Considera lanzar el error nuevamente o manejarlo de otra manera
      // dependiendo de tus necesidades
      throw error;
    }
  }
}

export default GeminiService;


/* ===================== Archivo: src\tests\test_gemini.ts ===================== */

import { GoogleGenerativeAI } from "@google/generative-ai";
import dotenv from "dotenv";

dotenv.config(); // Carga variables de entorno desde .env

const genAI = new GoogleGenerativeAI(process.env.GOOGLE_API_KEY!);
const model = genAI.getGenerativeModel({ model: "gemini-2.0-flash" });

async function testGemini() {
  try {
    const prompt = "Explica cómo funciona la energía solar en 3 puntos clave";
    const result = await model.generateContent(prompt);
    const response = await result.response;
    console.log("Respuesta de Gemini:");
    console.log(response.text());
  } catch (error) {
    console.error("Error al usar Gemini:", error);
  }
}

testGemini();


/* ===================== Archivo: src\utils\generateTimer.ts ===================== */

/**
 * Genera un número entero aleatorio entre min y max (ambos incluidos).
 * @param min - El valor mínimo del rango.
 * @param max - El valor máximo del rango.
 * @returns Un número entero aleatorio dentro del rango [min, max].
 * @throws Error si min es mayor que max.
 */
function generateTimer(min: number, max: number): number {
  // Validar que min sea menor o igual que max
  if (min > max) {
    throw new Error("El valor de 'min' debe ser menor o igual que 'max'.");
  }

  // Generar un número aleatorio en el rango [min, max]
  const numSal = Math.random(); // Genera un número entre 0 (incluido) y 1 (excluido)
  const numeroAleatorio = Math.floor(numSal * (max - min + 1)) + min;

  return numeroAleatorio;
}

export { generateTimer };


/* ===================== Archivo: src\utils\getCurrentDateTime.ts ===================== */

import { toZonedTime } from "date-fns-tz";
import { addDays, parse, format } from "date-fns";

/**
 * Obtiene la fecha y hora actuales en formato yyyy/MM/dd HH:mm:ss.
 * @returns Fecha y hora actuales.
 */
export const getCurrentDateTime = (): string => {
  return format(new Date(), "yyyy/MM/dd HH:mm:ss");
};

/**
 * Agrega minutos a una fecha dada.
 * @param date - La fecha inicial.
 * @param minutes - Los minutos a agregar.
 * @returns La nueva fecha.
 */
export const addMinutesToDate = (date: Date, minutes: number): Date => {
  return new Date(date.getTime() + minutes * 60000);
};

/**
 * Convierte una expresión relativa en una fecha absoluta.
 * @param input - La entrada del usuario (por ejemplo, "mañana a las 4pm").
 * @param currentDate - La fecha y hora actuales.
 * @returns Una fecha absoluta en formato yyyy/MM/dd HH:mm:ss.
 */
export const parseRelativeDate = (input: string, currentDate: Date): string => {
  const lowerInput = input.toLowerCase();

  // Manejar "mañana"
  if (lowerInput.includes("mañana")) {
    const timeMatch = lowerInput.match(/(\d{1,2}(?:am|pm))/);
    if (timeMatch) {
      const time = timeMatch[0];
      const parsedTime = parse(time, "h:mma", currentDate);
      const tomorrow = addDays(currentDate, 1);
      return format(
        new Date(
          tomorrow.getFullYear(),
          tomorrow.getMonth(),
          tomorrow.getDate(),
          parsedTime.getHours(),
          parsedTime.getMinutes()
        ),
        "yyyy/MM/dd HH:mm:ss"
      );
    }
  }

  // Manejar días específicos (por ejemplo, "el jueves")
  const daysOfWeek = [
    "domingo",
    "lunes",
    "martes",
    "miércoles",
    "jueves",
    "viernes",
    "sábado",
  ];
  for (let i = 0; i < daysOfWeek.length; i++) {
    if (lowerInput.includes(daysOfWeek[i])) {
      const timeMatch = lowerInput.match(/(\d{1,2}(?:am|pm))/);
      if (timeMatch) {
        const time = timeMatch[0];
        const parsedTime = parse(time, "h:mma", currentDate);
        const currentDay = currentDate.getDay();
        const targetDay = i;
        let daysToAdd = targetDay - currentDay;
        if (daysToAdd <= 0) daysToAdd += 7; // Asegura que sea en el futuro
        const targetDate = addDays(currentDate, daysToAdd);
        return format(
          new Date(
            targetDate.getFullYear(),
            targetDate.getMonth(),
            targetDate.getDate(),
            parsedTime.getHours(),
            parsedTime.getMinutes()
          ),
          "yyyy/MM/dd HH:mm:ss"
        );
      }
    }
  }

  // Si no se encuentra una coincidencia, lanzar un error
  throw new Error("No se pudo interpretar la fecha relativa.");
};


/* ===================== Archivo: src\utils\handledHistory.ts ===================== */

import { BotStateStandAlone } from "@builderbot/bot/dist/types";
export type History = { role: "user" | "assistant"; content: string };

// Esta agrega un nuevo mensaje al historial de conversación
const handleHistory = async (inside: History, _state: BotStateStandAlone) => {
  const history = _state.get<History[]>("history") ?? [];
  history.push(inside);
  await _state.update({ history });
};

// Recupera (k) mensajes del historial de conversación
const getHistory = (_state: BotStateStandAlone, k = 15) => {
  const history = _state.get<History[]>("history") ?? [];
  const limitHistory = history.slice(-k);
  return limitHistory;
};

// Convierte el historial en un formato legible (cadena de texto).
const getHistoryParse = (_state: BotStateStandAlone, k = 15): string => {
  const history = _state.get<History[]>("history") ?? [];
  const limitHistory = history.slice(-k);
  return limitHistory.reduce((prev, current) => {
    const msg =
      current.role === "user"
        ? `Customer: "${current.content}"`
        : `\nSeller: "${current.content}"\n`;
    prev += msg;
    return prev;
  }, ``);
};

// Limpia el historial de conversación
const clearHistory = async (_state: BotStateStandAlone) => {
  _state.clear();
};

export { handleHistory, getHistory, getHistoryParse, clearHistory };


/* ===================== Archivo: src\utils\logger.ts ===================== */

// src/utils/logger.ts

export const logger = {
  info: (...args: any[]) => console.info("[INFO]", ...args),
  debug: (...args: any[]) => console.debug("[DEBUG]", ...args),
  error: (...args: any[]) => console.error("[ERROR]", ...args),
};


/* ===================== Archivo: tsconfig.json ===================== */

{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "declaration": false,
    "declarationMap": false,
    "moduleResolution": "node",
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "sourceMap": false,
    "outDir": "./dist",
    "baseUrl": "./",
    "rootDir": "./",
    "incremental": true,
    "skipLibCheck": true,
    "resolveJsonModule": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "paths": {
      "~/*": ["./src/*"]
    }
  },
  "include": ["**/*.js", "**/*.ts"],
  "exclude": [
    "node_modules",
    "dist",
    "**/*.test.ts",
    "**/*.spec.ts",
    "**e2e**",
    "**mock**"
  ]
}
